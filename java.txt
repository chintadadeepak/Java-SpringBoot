Static keyword
static variables shared by all the objects.
static variables are the class members not the object members
they can be accessed with class name.

class Mobile {
    String brand;
    int price;
    static String name;

    public void show() {
        System.out.println(brand + " : " + price + " : " + name);
    }
}


Mobile obj1 = new Mobile();
obj1.brand = "Apple";
obj1.price = 1500;
Mobile.name = "SmartPhone";
Mobile obj2 = new Mobile();
obj2.brand = "Samsung";
obj2.price = 1700;
Mobile.name = "Phone";
obj1.show();
obj2.show();

Static Method
// static variables inside non-static method - accepted
// static variables inside static method - accepted
// non - static variables inside non-static method - accepted
// non - static variables inside static method - not accepted directly
// but indirectly we can accept them i.e by passing object reference

class Mobile {
    String brand;
    int price;
    static String name;

    public static void show(Mobile obj) {
        System.out.println(obj.brand + " : " + obj.price + " : " + name);
    }
}

Mobile obj1 = new Mobile();
obj1.brand = "Apple";
obj1.price = 1500;
Mobile.name = "SmartPhone";
Mobile obj2 = new Mobile();
obj2.brand = "Samsung";
obj2.price = 1700;
// Mobile.name = "Phone";
Mobile.show(obj1);
Mobile.show(obj2);


// static block 
// used for intializing the static variables at the time of class loading.
// as we know JVM will creates an object by taking the class as an input
// in order to create an object JVM first loads the class into the class loader 
// so the static block and everything will be executed
// next time as the class was already loaded no static block will be executed
// only constructor will be called at the time of object creation.
// with creating an object class will be loaded with forName(). 
class Mobile {
    String brand;
    int price;
    static String name;

    // syntax for intializing the static variables
    static {
        name = "Phone";
        System.out.println("in static block");
    }

    Mobile() {
        brand = "Nokia";
        price = 500;
        System.out.println("in constructor");
    }

    // public static void show(Mobile obj) {
    // System.out.println(obj.brand + " : " + obj.price + " : " + name);
    // }
}


Class.forName("Mobile");
// Mobile obj1 = new Mobile();
// obj1.brand = "Apple";
// obj1.price = 1500;
// Mobile.name = "SmartPhone";
// Mobile obj2 = new Mobile();
// obj2.brand = "Samsung";
// obj2.price = 1700;
// Mobile.name = "Phone";
// Mobile.show(obj1);
// Mobile.show(obj2);

// Encapsulation - process of binding of data with methods.
// setters and getters - fetching and setting the data with methods
class Mobile {
    private int age;
    private String name;

    public void setAge(int age) {
        this.age = age;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public String getName() {
        return name;
    }
}

Mobile obj = new Mobile();
obj.setAge(20);
obj.setName("Deepak");
System.out.println(obj.getAge() + " : " + obj.getName());


// constructor - Method which was used to intialize the instance variables
// Called whenever we create an object
// No return type and same name as className.

// constructor which does not take anything is called as default constructor
// constructor which takes parameters is called as parameterized constructor

class Mobile {
    private int age;
    private String name;

    Mobile() {
        System.out.println("Default Constructor");
    }

    Mobile(int age, String name) {
        this.age = age;
        this.name = name;
    }

    // public void setAge(int age) {
    // this.age = age;
    // }

    // public void setName(String name) {
    // this.name = name;
    // }

    public int getAge() {
        return age;
    }

    public String getName() {
        return name;
    }
}


// this and super method
// this() - calls the current class constructor
// super() - calls the super class constructor

class Parent extends Object {
    Parent() {
        super();
        System.out.println("Parent constructor");
    }

    Parent(int num) {
        super();
        System.out.println("Parent parameterized constructor");
    }
}

class Child extends Parent {
    Child() {
        super();
        System.out.println("Child constructor");
    }

    Child(int num) {
        this();
        System.out.println("Child parameterized constructor");
    }
}

// anonymous object
// an object which does not have reference 
// it can not be used more than once.
// object creation involves two steps
// 1. object creation
// 2. assigning that address to the reference variable.
class Mobile {
    Mobile() {
        System.out.println("in constructor..");
    }

    public void show() {
        System.out.println("in show method..");
    }
}

new Mobile().show();
// anonynous object
new Mobile().show();

// inheritance
// process of acquiring the properties and methods
// from a base class by the derived class

VeryAdvCalc obj = new VeryAdvCalc();
int r1 = obj.add(3, 4);
int r2 = obj.sub(5, 2);
int r3 = obj.multi(3, 4);
int r4 = obj.div(5, 2);
double r5 = obj.power(3, 4);
System.out.println(r1 + " : " + r2);
System.out.println(r3 + " : " + r4 + " : " + r5);

// Multiple inheritance is not supported in java because
// of the ambiguity


// packages
// packages are the modules where related grouped files are kept inside a folder

// access-modifiers 
// access-modifiers will allow users to access the methods and instance variables based
// based upon the access given to them

public:
same class - true
same package - subclass - true
same package - non-subclass - true 
different package - subclass - true
different package - non-subclass - true


private:
same class - true
same package - subclass - false
same package - non-subclass - false 
different package - subclass - false
different package - non-subclass - false


default:
same class - true
same package - subclass - true
same package - non-subclass - true 
different package - subclass - false
different package - non-subclass - false


protected:
same class - true
same package - subclass - true
same package - non-subclass - true 
different package - subclass - true
different package - non-subclass - false

// polymorphism - poly - many, morphism - behaviour
// the reference will show different bahaviour based upon the way that the object you
// are assigning to that reference

// polymorphism is of two types
// 1. compile time polymorphism --> method overloading
// 2. run time polymorphism --> method overriding, dynamic method dispatch
// runtime polymorphism here is depending upon the object that you are it's method
// will be executed

// dynamic method dispatch
// you can assign the child implementation to the parent reference
// because every child is derived from the parent
class Parent {
    public void show() {
        System.out.println("In parent");
    }
}

class Child1 extends Parent {
    public void show() {
        System.out.println("In child-1");
    }
}

class Child2 extends Parent {
    public void show() {
        System.out.println("In child-2");
    }
}

Parent obj = new Parent(); // both object implementation and reference type is Parent
                                   // parent method will be called
obj.show();
obj = new Child1(); // reference parent type and implementation child type.
obj.show();
obj = new Child2(); // reference parent type and implementation child type.
obj.show();

// final variable - final makes a variable constant.
// final class - Final class can not be inherited
// final method - stopping the method overriding

class Parent {
    public final void show() {
        System.out.println("in Parent");
    }
}

class Child extends Parent {
    // public void show() {
    //     System.out.println("in Child");
    // }
}

// final float PIE = 3.14f;
// PIE = 3.15f;
Child obj = new Child();
obj.show();





